{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Here is a solution for the four tasks based on the provided guidelines. I will provide a comprehensive explanation of each task, followed by a Python script implementation. The solution will be presented in the context of a Markdown document. Below is the full response, ready to be used in your project: Investigating the Range as a Function of the Angle of Projection Motivation: Projectile motion is a classic topic in physics that explores the trajectory of an object launched into the air. The relationship between the launch angle and range, combined with parameters like initial velocity and gravity, is fundamental to various real-world scenarios. From sports to space exploration, understanding this relationship has wide-ranging applications. 1. Theoretical Foundation 1.1 Governing Equations of Motion The fundamental equations governing projectile motion come from Newton's laws of motion, applied to the x- and y-axes separately. We start by assuming a projectile is launched from ground level (or a given height) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) . Horizontal motion (x-direction) : The horizontal velocity remains constant throughout the flight since there's no horizontal acceleration (ignoring air resistance). $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion (y-direction) : The vertical motion is influenced by gravity, which causes a constant downward acceleration \\(g\\) . $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ The time of flight \\(T\\) (the time when the projectile hits the ground) is obtained by solving for \\(t\\) when \\(y(t) = 0\\) . This gives: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range (R) : The horizontal range is the distance the projectile travels in the x-direction during the time of flight: $$ R = v_0 \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ 1.2 Family of Solutions The general solution to the equations of motion can be adjusted for different initial conditions (initial velocity \\(v_0\\) , gravitational acceleration \\(g\\) , and launch height \\(h\\) ). For a launch from a height \\(h\\) , the trajectory equation is modified to: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 + h \\] To solve for the time of flight and the range in this case, you would solve the quadratic equation for \\(t\\) when \\(y(t) = 0\\) , then calculate the range as before. 2. Analysis of the Range 2.1 Dependence of the Range on the Launch Angle The range equation \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) shows that: Maximum range occurs at \\(\\theta = 45^\\circ\\) : This angle maximizes \\(\\sin(2\\theta)\\) , giving the longest possible range for a given initial velocity and gravitational acceleration. Symmetry : \\(R(\\theta) = R(90^\\circ - \\theta)\\) , meaning that the range is the same for angles symmetric around \\(45^\\circ\\) . 2.2 Influence of Other Parameters Initial velocity \\(v_0\\) : The range is proportional to the square of the initial velocity. Doubling the initial velocity results in a fourfold increase in range. Gravitational acceleration \\(g\\) : The range is inversely proportional to \\(g\\) . In a lower-gravity environment (like on the Moon), the range would be larger for the same initial velocity and launch angle. Launch height \\(h\\) : A higher launch height increases the range since the projectile spends more time in the air. 3. Practical Applications This model can be adapted to real-world situations with some modifications: Uneven Terrain : If the projectile is launched from a hill or mountain, the height \\(h\\) should be adjusted to reflect this elevation. The range equation can be adjusted by incorporating the effect of the slope of the terrain. Air Resistance (Drag) : In real-world conditions, air resistance plays a significant role, especially at high velocities. The drag force is proportional to the square of the velocity, and it requires solving differential equations numerically. This makes the problem more complex but can be simulated using numerical methods like Euler\u2019s method or Runge-Kutta methods. Wind : Wind can affect the horizontal motion of the projectile, introducing a horizontal force component. To model this, you would include wind velocity in the equations of motion. Rocket Launches : In the case of a rocket, variable acceleration and changing mass (due to fuel consumption) need to be considered. 4. Implementation Python Code Implementation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles_deg = 45 v0_list = [30, 40, 50] colors = ['red', 'purple', 'green'] # Set up plot fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlabel('x') ax.set_ylabel('y') # Loop over each velocity for v0, color in zip(v0_list, colors): theta = np.radians(angles_deg) vx = v0 * np.cos(theta) vy = v0 * np.sin(theta) t_flight = 2 * vy / g t = np.linspace(0, t_flight, 300) x = vx * t y = vy * t - 0.5 * g * t**2 ax.plot(x, y, color=color) # Add velocity arrows ax.arrow(0, 0, vx * 0.5, vy * 0.5, head_width=2, head_length=2, fc=color, ec=color) ax.text(vx * 0.5 + 2, vy * 0.5, f\"{v0} m/s\", color=color, fontsize=10) # Add horizontal range indicators ranges = [91.8, 163, 255] for r in ranges: ax.plot([r, r], [0, 1], 'k--', linewidth=0.8) # Add R labels ax.text(91.8 / 2 - 5, -2, \"R = 91.8 m\", fontsize=9) ax.text(91.8 + (163 - 91.8) / 2 - 10, -2, \"R = 163 m\", fontsize=9) ax.text(255 / 2 - 10, -5, \"R = 255 m\", fontsize=9) # Set axis limits ax.set_xlim(0, 270) ax.set_ylim(0, 70) # Axes ax.axhline(0, color='black', linewidth=1) ax.arrow(0, 0, 0, 60, head_width=5, head_length=3, fc='k', ec='k') # y-axis ax.arrow(0, 0, 260, 0, head_width=3, head_length=5, fc='k', ec='k') # x-axis ax.text(265, -2, 'x', fontsize=12) ax.text(-5, 65, 'y', fontsize=12) plt.title(\"Projectile Motions at 45\u00b0 with Different Initial Speeds\") plt.grid(False) plt.tight_layout() plt.show() Description of the Python Code: Function compute_range : This function calculates the range of a projectile given the initial velocity, launch angle, and height. It supports both ground-level launches and launches from an elevated position. Plotting : The script generates two sets of plots: The first set compares the ranges for different initial velocities at ground level. The second set compares the ranges when the projectile is launched from a height of 5 meters. Limitations of the Model: Idealized Assumptions : This model assumes no air resistance and constant gravitational acceleration. Uniform Terrain : The model assumes the terrain is flat; launching from a slope requires modifications. No Wind : Wind effects are ignored, which is not realistic in many real-world applications. Realistic Extensions: To model air resistance, drag coefficients must be included in the equations. Wind speed and direction would need to be modeled as external forces affecting the horizontal velocity. Conclusion In this project, we investigated how the range of a projectile depends on its launch angle and initial conditions. The theoretical model highlighted the interplay between initial velocity, gravitational acceleration, and launch height. We implemented a Python simulation to visualize the range versus launch angle for various initial velocities. While the model is idealized, real-world factors such as air resistance, wind, and terrain can further influence the projectile's trajectory, leading to more complex simulations. Colab Visit my colab: link","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Here is a solution for the four tasks based on the provided guidelines. I will provide a comprehensive explanation of each task, followed by a Python script implementation. The solution will be presented in the context of a Markdown document. Below is the full response, ready to be used in your project:","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is a classic topic in physics that explores the trajectory of an object launched into the air. The relationship between the launch angle and range, combined with parameters like initial velocity and gravity, is fundamental to various real-world scenarios. From sports to space exploration, understanding this relationship has wide-ranging applications.","title":"Motivation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations-of-motion","text":"The fundamental equations governing projectile motion come from Newton's laws of motion, applied to the x- and y-axes separately. We start by assuming a projectile is launched from ground level (or a given height) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) . Horizontal motion (x-direction) : The horizontal velocity remains constant throughout the flight since there's no horizontal acceleration (ignoring air resistance). $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion (y-direction) : The vertical motion is influenced by gravity, which causes a constant downward acceleration \\(g\\) . $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ The time of flight \\(T\\) (the time when the projectile hits the ground) is obtained by solving for \\(t\\) when \\(y(t) = 0\\) . This gives: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range (R) : The horizontal range is the distance the projectile travels in the x-direction during the time of flight: $$ R = v_0 \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} $$","title":"1.1 Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-family-of-solutions","text":"The general solution to the equations of motion can be adjusted for different initial conditions (initial velocity \\(v_0\\) , gravitational acceleration \\(g\\) , and launch height \\(h\\) ). For a launch from a height \\(h\\) , the trajectory equation is modified to: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 + h \\] To solve for the time of flight and the range in this case, you would solve the quadratic equation for \\(t\\) when \\(y(t) = 0\\) , then calculate the range as before.","title":"1.2 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-dependence-of-the-range-on-the-launch-angle","text":"The range equation \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) shows that: Maximum range occurs at \\(\\theta = 45^\\circ\\) : This angle maximizes \\(\\sin(2\\theta)\\) , giving the longest possible range for a given initial velocity and gravitational acceleration. Symmetry : \\(R(\\theta) = R(90^\\circ - \\theta)\\) , meaning that the range is the same for angles symmetric around \\(45^\\circ\\) .","title":"2.1 Dependence of the Range on the Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-influence-of-other-parameters","text":"Initial velocity \\(v_0\\) : The range is proportional to the square of the initial velocity. Doubling the initial velocity results in a fourfold increase in range. Gravitational acceleration \\(g\\) : The range is inversely proportional to \\(g\\) . In a lower-gravity environment (like on the Moon), the range would be larger for the same initial velocity and launch angle. Launch height \\(h\\) : A higher launch height increases the range since the projectile spends more time in the air.","title":"2.2 Influence of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model can be adapted to real-world situations with some modifications: Uneven Terrain : If the projectile is launched from a hill or mountain, the height \\(h\\) should be adjusted to reflect this elevation. The range equation can be adjusted by incorporating the effect of the slope of the terrain. Air Resistance (Drag) : In real-world conditions, air resistance plays a significant role, especially at high velocities. The drag force is proportional to the square of the velocity, and it requires solving differential equations numerically. This makes the problem more complex but can be simulated using numerical methods like Euler\u2019s method or Runge-Kutta methods. Wind : Wind can affect the horizontal motion of the projectile, introducing a horizontal force component. To model this, you would include wind velocity in the equations of motion. Rocket Launches : In the case of a rocket, variable acceleration and changing mass (due to fuel consumption) need to be considered.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles_deg = 45 v0_list = [30, 40, 50] colors = ['red', 'purple', 'green'] # Set up plot fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlabel('x') ax.set_ylabel('y') # Loop over each velocity for v0, color in zip(v0_list, colors): theta = np.radians(angles_deg) vx = v0 * np.cos(theta) vy = v0 * np.sin(theta) t_flight = 2 * vy / g t = np.linspace(0, t_flight, 300) x = vx * t y = vy * t - 0.5 * g * t**2 ax.plot(x, y, color=color) # Add velocity arrows ax.arrow(0, 0, vx * 0.5, vy * 0.5, head_width=2, head_length=2, fc=color, ec=color) ax.text(vx * 0.5 + 2, vy * 0.5, f\"{v0} m/s\", color=color, fontsize=10) # Add horizontal range indicators ranges = [91.8, 163, 255] for r in ranges: ax.plot([r, r], [0, 1], 'k--', linewidth=0.8) # Add R labels ax.text(91.8 / 2 - 5, -2, \"R = 91.8 m\", fontsize=9) ax.text(91.8 + (163 - 91.8) / 2 - 10, -2, \"R = 163 m\", fontsize=9) ax.text(255 / 2 - 10, -5, \"R = 255 m\", fontsize=9) # Set axis limits ax.set_xlim(0, 270) ax.set_ylim(0, 70) # Axes ax.axhline(0, color='black', linewidth=1) ax.arrow(0, 0, 0, 60, head_width=5, head_length=3, fc='k', ec='k') # y-axis ax.arrow(0, 0, 260, 0, head_width=3, head_length=5, fc='k', ec='k') # x-axis ax.text(265, -2, 'x', fontsize=12) ax.text(-5, 65, 'y', fontsize=12) plt.title(\"Projectile Motions at 45\u00b0 with Different Initial Speeds\") plt.grid(False) plt.tight_layout() plt.show()","title":"Python Code Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#description-of-the-python-code","text":"Function compute_range : This function calculates the range of a projectile given the initial velocity, launch angle, and height. It supports both ground-level launches and launches from an elevated position. Plotting : The script generates two sets of plots: The first set compares the ranges for different initial velocities at ground level. The second set compares the ranges when the projectile is launched from a height of 5 meters.","title":"Description of the Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-of-the-model","text":"Idealized Assumptions : This model assumes no air resistance and constant gravitational acceleration. Uniform Terrain : The model assumes the terrain is flat; launching from a slope requires modifications. No Wind : Wind effects are ignored, which is not realistic in many real-world applications.","title":"Limitations of the Model:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#realistic-extensions","text":"To model air resistance, drag coefficients must be included in the equations. Wind speed and direction would need to be modeled as external forces affecting the horizontal velocity.","title":"Realistic Extensions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"In this project, we investigated how the range of a projectile depends on its launch angle and initial conditions. The theoretical model highlighted the interplay between initial velocity, gravitational acceleration, and launch height. We implemented a Python simulation to visualize the range versus launch angle for various initial velocities. While the model is idealized, real-world factors such as air resistance, wind, and terrain can further influence the projectile's trajectory, leading to more complex simulations.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab","text":"Visit my colab: link","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Here is a comprehensive, structured response to your project on \u201cInvestigating the Dynamics of a Forced Damped Pendulum\u201d , including theoretical derivations, simulation guidelines, and deliverable suggestions. This version is suitable for use in a Markdown document or Python notebook. \ud83d\udcd8 Investigating the Dynamics of a Forced Damped Pendulum \ud83e\udde0 Motivation The forced damped pendulum offers a rich canvas to explore nonlinear dynamics, showcasing behaviors from predictable harmonic oscillations to chaotic motion. These dynamics are not just academic curiosities\u2014they underpin real-world systems in engineering, physics, and nature, including suspension bridges, driven electronic circuits, and even human biomechanics. 1\ufe0f\u20e3 Theoretical Foundation \u2699\ufe0f Governing Equation The general equation for a forced, damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta\\) : Angular displacement \\(b\\) : Damping coefficient \\(g\\) : Acceleration due to gravity \\(L\\) : Length of the pendulum \\(A\\) : Driving force amplitude \\(\\omega\\) : Driving frequency \ud83e\uddee Small-Angle Approximation For small \\(\\theta\\) , we use \\(\\sin(\\theta) \\approx \\theta\\) , yielding: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear nonhomogeneous second-order differential equation, with a general solution consisting of: Homogeneous solution (transient behavior) Particular solution (steady-state behavior) \u2705 Resonance Resonance occurs when \\(\\omega \\approx \\sqrt{\\frac{g}{L}}\\) . At this point, the pendulum absorbs maximum energy from the driver, and oscillation amplitudes peak (limited by damping). 2\ufe0f\u20e3 Analysis of Dynamics \ud83d\udd01 Parameters Affecting Motion Damping Coefficient \\(b\\) : Low \\(b\\) : oscillations persist or grow (if driven). High \\(b\\) : oscillations quickly decay. Driving Amplitude \\(A\\) : Larger \\(A\\) can drive the system into nonlinear or chaotic regimes. Driving Frequency \\(\\omega\\) : Near resonance: increased amplitude. Far from resonance: suppressed oscillations. \ud83c\udf00 Regular vs. Chaotic Behavior Regular motion : Periodic, predictable. Chaotic motion : Sensitive to initial conditions, non-periodic, strange attractors emerge. Key Tool : Poincar\u00e9 sections reveal chaos by showing where the system is at regular intervals of the driving period. 3\ufe0f\u20e3 Practical Applications Energy harvesting : Resonant mechanical systems tuned to vibrations (e.g., piezoelectric devices). Suspension bridges : External forcing (e.g., wind) can cause resonant oscillations (e.g., Tacoma Narrows). RLC circuits : Analogous differential equation governs voltage/current behavior in driven, damped circuits. 4\ufe0f\u20e3 Implementation \u2013 Python Simulation \ud83d\udd27 Numerical Method Use Runge-Kutta (RK4) or scipy.integrate.solve_ivp to numerically integrate: \\[ \\begin{cases} \\frac{d\\theta}{dt} = \\omega \\\\ \\frac{d\\omega}{dt} = -b\\omega - \\frac{g}{L}\\sin(\\theta) + A\\cos(\\omega_{\\text{drive}} t) \\end{cases} \\] \ud83d\udcca Visualizations Time series plots of \\(\\theta(t)\\) to observe resonance and chaos. Phase portraits \\((\\theta, \\omega)\\) to visualize periodicity and attractors. Poincar\u00e9 sections \\((\\theta, \\omega)\\) at discrete times \\(t = nT\\) , \\(T = \\frac{2\\pi}{\\omega_{\\text{drive}}}\\) . Bifurcation diagrams : Plot final \\(\\theta\\) values vs. driving amplitude/frequency to reveal transitions. \ud83e\udde9 Sample Python Snippet import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, L = 9.81, 1.0 b, A, omega_drive = 0.5, 1.2, 2/3 def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -b*omega - (g/L)*np.sin(theta) + A*np.cos(omega_drive*t) return [dtheta_dt, domega_dt] # Solve t_span = (0, 100) y0 = [0.2, 0.0] t_eval = np.linspace(*t_span, 10000) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot plt.plot(t_eval, sol.y[0]) plt.xlabel(\"Time\") plt.ylabel(\"Theta\") plt.title(\"Forced Damped Pendulum Motion\") plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Here is a comprehensive, structured response to your project on \u201cInvestigating the Dynamics of a Forced Damped Pendulum\u201d , including theoretical derivations, simulation guidelines, and deliverable suggestions. This version is suitable for use in a Markdown document or Python notebook.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83d\udcd8 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum offers a rich canvas to explore nonlinear dynamics, showcasing behaviors from predictable harmonic oscillations to chaotic motion. These dynamics are not just academic curiosities\u2014they underpin real-world systems in engineering, physics, and nature, including suspension bridges, driven electronic circuits, and even human biomechanics.","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1\ufe0f\u20e3 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The general equation for a forced, damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta\\) : Angular displacement \\(b\\) : Damping coefficient \\(g\\) : Acceleration due to gravity \\(L\\) : Length of the pendulum \\(A\\) : Driving force amplitude \\(\\omega\\) : Driving frequency","title":"\u2699\ufe0f Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\(\\theta\\) , we use \\(\\sin(\\theta) \\approx \\theta\\) , yielding: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear nonhomogeneous second-order differential equation, with a general solution consisting of: Homogeneous solution (transient behavior) Particular solution (steady-state behavior)","title":"\ud83e\uddee Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when \\(\\omega \\approx \\sqrt{\\frac{g}{L}}\\) . At this point, the pendulum absorbs maximum energy from the driver, and oscillation amplitudes peak (limited by damping).","title":"\u2705 Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2\ufe0f\u20e3 Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters-affecting-motion","text":"Damping Coefficient \\(b\\) : Low \\(b\\) : oscillations persist or grow (if driven). High \\(b\\) : oscillations quickly decay. Driving Amplitude \\(A\\) : Larger \\(A\\) can drive the system into nonlinear or chaotic regimes. Driving Frequency \\(\\omega\\) : Near resonance: increased amplitude. Far from resonance: suppressed oscillations.","title":"\ud83d\udd01 Parameters Affecting Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-behavior","text":"Regular motion : Periodic, predictable. Chaotic motion : Sensitive to initial conditions, non-periodic, strange attractors emerge. Key Tool : Poincar\u00e9 sections reveal chaos by showing where the system is at regular intervals of the driving period.","title":"\ud83c\udf00 Regular vs. Chaotic Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy harvesting : Resonant mechanical systems tuned to vibrations (e.g., piezoelectric devices). Suspension bridges : External forcing (e.g., wind) can cause resonant oscillations (e.g., Tacoma Narrows). RLC circuits : Analogous differential equation governs voltage/current behavior in driven, damped circuits.","title":"3\ufe0f\u20e3 Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"","title":"4\ufe0f\u20e3 Implementation \u2013 Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-method","text":"Use Runge-Kutta (RK4) or scipy.integrate.solve_ivp to numerically integrate: \\[ \\begin{cases} \\frac{d\\theta}{dt} = \\omega \\\\ \\frac{d\\omega}{dt} = -b\\omega - \\frac{g}{L}\\sin(\\theta) + A\\cos(\\omega_{\\text{drive}} t) \\end{cases} \\]","title":"\ud83d\udd27 Numerical Method"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualizations","text":"Time series plots of \\(\\theta(t)\\) to observe resonance and chaos. Phase portraits \\((\\theta, \\omega)\\) to visualize periodicity and attractors. Poincar\u00e9 sections \\((\\theta, \\omega)\\) at discrete times \\(t = nT\\) , \\(T = \\frac{2\\pi}{\\omega_{\\text{drive}}}\\) . Bifurcation diagrams : Plot final \\(\\theta\\) values vs. driving amplitude/frequency to reveal transitions.","title":"\ud83d\udcca Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#sample-python-snippet","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, L = 9.81, 1.0 b, A, omega_drive = 0.5, 1.2, 2/3 def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -b*omega - (g/L)*np.sin(theta) + A*np.cos(omega_drive*t) return [dtheta_dt, domega_dt] # Solve t_span = (0, 100) y0 = [0.2, 0.0] t_eval = np.linspace(*t_span, 10000) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot plt.plot(t_eval, sol.y[0]) plt.xlabel(\"Time\") plt.ylabel(\"Theta\") plt.title(\"Forced Damped Pendulum Motion\") plt.show()","title":"\ud83e\udde9 Sample Python Snippet"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius: Kepler's Third Law Motivation Kepler\u2019s Third Law provides a powerful insight into celestial mechanics, stating that: \"The square of the orbital period of a planet is directly proportional to the cube of the semi-major axis of its orbit.\" For circular orbits, this becomes a fundamental relationship between the orbital period and orbital radius. This principle is critical in astronomy for calculating planetary distances, masses of celestial bodies, and designing satellite orbits. \\[ T^2 \\propto r^3 \\] This elegant relationship provides deep insight into the motion of celestial bodies and has real-world applications in calculating satellite trajectories, determining planetary masses, and exploring distant exoplanets. 1. Derivation of Kepler\u2019s Third Law for Circular Orbits For an object of mass \\(m\\) in a circular orbit around a much more massive object of mass \\(M\\) , gravitational force provides the required centripetal force. Newton\u2019s Law of Gravitation: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Centripetal Force: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Equating both: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital Period: \\[ T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2} = \\frac{4\\pi^2 r^3}{G M} \\] Thus: \\[ \\boxed{T^2 \\propto r^3} \\] 2. Implications in Astronomy Mass Estimation : Planetary masses are derived by observing their satellites' orbits. Distance Calculation : Semi-major axis of exoplanets can be estimated using orbital periods. Satellite Orbits : Engineers use this principle to design satellite altitudes and periods. Generalization to Elliptical Orbits : Still holds with \\(r\\) replaced by the semi-major axis \\(a\\) . 3. Real-World Examples Moon's Orbit Around Earth Radius \\(r \\approx 3.84 \\times 10^8\\) m Period \\(T \\approx 2.36 \\times 10^6\\) s Using \\(T^2 = \\frac{4\\pi^2 r^3}{G M}\\) , we can solve for \\(M \\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) (Earth\u2019s mass) Planets in the Solar System Each planet follows \\(T^2 \\propto r^3\\) . For example: Earth: \\(T = 1\\) year, \\(r = 1\\) AU Mars: \\(T^2 = 1.88^2 \\approx 3.53\\) , \\(r^3 = 1.52^3 \\approx 3.51\\) 4. Python Simulation: Verifying Kepler\u2019s Third Law import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # Mass of Earth in kg # Orbital radii (in meters) radii = np.linspace(7e6, 4.2e7, 100) # 7000 km to 42000 km T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Orbital period # Plot T^2 vs r^3 to verify Kepler's 3rd Law plt.figure(figsize=(10, 6)) plt.plot(radii**3, T**2, label=r'$T^2$ vs $r^3$', color='navy') plt.xlabel('Orbital Radius Cubed (m\u00b3)', fontsize=12) plt.ylabel('Orbital Period Squared (s\u00b2)', fontsize=12) plt.title(\"Kepler's Third Law: $T^2 \\\\propto r^3$\", fontsize=14) plt.grid(True) plt.legend() plt.tight_layout() plt.show() 5. Circular Orbit Visualization theta = np.linspace(0, 2*np.pi, 100) x = np.cos(theta) y = np.sin(theta) plt.figure(figsize=(6, 6)) plt.plot(x, y, label=\"Orbit Path\") plt.plot(0, 0, 'yo', label=\"Central Body (e.g., Earth)\") plt.axis('equal') plt.title(\"Circular Orbit Visualization\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() 6. Extension to Elliptical Orbits Kepler's Third Law applies to elliptical orbits by replacing \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G(M + m)} \\approx \\frac{4\\pi^2 a^3}{G M} \\quad \\text{if } m \\ll M \\] This holds true for planets, comets, and exoplanets. For orbits with high eccentricity, the relationship remains accurate using the average distance. Conclusion Kepler\u2019s Third Law reveals a universal law governing orbital motion. From satellite technology to galactic dynamics, this principle enables scientists and engineers to probe and predict celestial behaviors with precision. Through computational modeling, we verified: \\[ T^2 \\propto r^3 \\] \u2014 bridging classical physics and modern astrophysics.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law provides a powerful insight into celestial mechanics, stating that: \"The square of the orbital period of a planet is directly proportional to the cube of the semi-major axis of its orbit.\" For circular orbits, this becomes a fundamental relationship between the orbital period and orbital radius. This principle is critical in astronomy for calculating planetary distances, masses of celestial bodies, and designing satellite orbits. \\[ T^2 \\propto r^3 \\] This elegant relationship provides deep insight into the motion of celestial bodies and has real-world applications in calculating satellite trajectories, determining planetary masses, and exploring distant exoplanets.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law-for-circular-orbits","text":"For an object of mass \\(m\\) in a circular orbit around a much more massive object of mass \\(M\\) , gravitational force provides the required centripetal force.","title":"1. Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-gravitation","text":"\\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\]","title":"Newton\u2019s Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force","text":"\\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Equating both: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\]","title":"Centripetal Force:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period","text":"\\[ T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2} = \\frac{4\\pi^2 r^3}{G M} \\] Thus: \\[ \\boxed{T^2 \\propto r^3} \\]","title":"Orbital Period:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-in-astronomy","text":"Mass Estimation : Planetary masses are derived by observing their satellites' orbits. Distance Calculation : Semi-major axis of exoplanets can be estimated using orbital periods. Satellite Orbits : Engineers use this principle to design satellite altitudes and periods. Generalization to Elliptical Orbits : Still holds with \\(r\\) replaced by the semi-major axis \\(a\\) .","title":"2. Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#moons-orbit-around-earth","text":"Radius \\(r \\approx 3.84 \\times 10^8\\) m Period \\(T \\approx 2.36 \\times 10^6\\) s Using \\(T^2 = \\frac{4\\pi^2 r^3}{G M}\\) , we can solve for \\(M \\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) (Earth\u2019s mass)","title":"Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"Each planet follows \\(T^2 \\propto r^3\\) . For example: Earth: \\(T = 1\\) year, \\(r = 1\\) AU Mars: \\(T^2 = 1.88^2 \\approx 3.53\\) , \\(r^3 = 1.52^3 \\approx 3.51\\)","title":"Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-verifying-keplers-third-law","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # Mass of Earth in kg # Orbital radii (in meters) radii = np.linspace(7e6, 4.2e7, 100) # 7000 km to 42000 km T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Orbital period # Plot T^2 vs r^3 to verify Kepler's 3rd Law plt.figure(figsize=(10, 6)) plt.plot(radii**3, T**2, label=r'$T^2$ vs $r^3$', color='navy') plt.xlabel('Orbital Radius Cubed (m\u00b3)', fontsize=12) plt.ylabel('Orbital Period Squared (s\u00b2)', fontsize=12) plt.title(\"Kepler's Third Law: $T^2 \\\\propto r^3$\", fontsize=14) plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"4. Python Simulation: Verifying Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-circular-orbit-visualization","text":"theta = np.linspace(0, 2*np.pi, 100) x = np.cos(theta) y = np.sin(theta) plt.figure(figsize=(6, 6)) plt.plot(x, y, label=\"Orbit Path\") plt.plot(0, 0, 'yo', label=\"Central Body (e.g., Earth)\") plt.axis('equal') plt.title(\"Circular Orbit Visualization\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"5. Circular Orbit Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-extension-to-elliptical-orbits","text":"Kepler's Third Law applies to elliptical orbits by replacing \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G(M + m)} \\approx \\frac{4\\pi^2 a^3}{G M} \\quad \\text{if } m \\ll M \\] This holds true for planets, comets, and exoplanets. For orbits with high eccentricity, the relationship remains accurate using the average distance.","title":"6. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law reveals a universal law governing orbital motion. From satellite technology to galactic dynamics, this principle enables scientists and engineers to probe and predict celestial behaviors with precision. Through computational modeling, we verified: \\[ T^2 \\propto r^3 \\] \u2014 bridging classical physics and modern astrophysics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation Understanding the speeds required to enter orbit, escape planetary gravity, or even leave the Solar System is foundational to space exploration. These speeds\u2014called cosmic velocities \u2014determine how we launch satellites, send missions to other planets, and plan interstellar probes. 1. Definitions of Cosmic Velocities Cosmic Velocity Description Formula First ( \\(v_1\\) ) Minimum speed to achieve stable circular orbit near the surface \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second ( \\(v_2\\) ) Minimum speed to escape the planet\u2019s gravity \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) Third ( \\(v_3\\) ) Speed to escape the star system from a planet\u2019s orbit \\(v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2}\\) Where: \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}\\) \\(M\\) : Mass of the celestial body \\(R\\) : Radius of the celestial body 2. Mathematical Derivations First Cosmic Velocity For a stable circular orbit at radius \\(R\\) : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Second Cosmic Velocity (Escape Velocity) Set total energy to zero (kinetic + gravitational potential): \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{R}} \\] Third Cosmic Velocity Escape velocity from the Sun starting from Earth\u2019s orbit: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{Earth orbit}}^2} \\] Where \\(v_{\\text{Earth orbit}} \\approx 29.78 \\times 10^3\\) m/s. 3. Python Code: Computing Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 # Celestial bodies: name -> (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } def compute_cosmic_velocities(mass, radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 return v1, v2 # Compute velocities results = {} for planet, (mass, radius) in bodies.items(): v1, v2 = compute_cosmic_velocities(mass, radius) results[planet] = {'v1': v1, 'v2': v2} # Display results for planet, v in results.items(): print(f\"{planet}:\") print(f\" First Cosmic Velocity (v1): {v['v1']:.2f} m/s\") print(f\" Second Cosmic Velocity (v2): {v['v2']:.2f} m/s\\n\") Earth: First Cosmic Velocity (v1): 7909.68 m/s Second Cosmic Velocity (v2): 11185.98 m/s Mars: First Cosmic Velocity (v1): 3554.68 m/s Second Cosmic Velocity (v2): 5027.08 m/s Jupiter: First Cosmic Velocity (v1): 42567.51 m/s Second Cosmic Velocity (v2): 60199.54 m/s 4. Visualization Bar Chart of Velocities labels = list(results.keys()) v1_vals = [results[planet]['v1'] for planet in labels] v2_vals = [results[planet]['v2'] for planet in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_vals, width, label='2nd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show() 5. Third Cosmic Velocity (Escape the Solar System) From Earth: \\(v_2 \\approx 11.2 \\times 10^3 \\, \\text{m/s}\\) \\(v_{\\text{Earth orbit}} \\approx 29.78 \\times 10^3 \\, \\text{m/s}\\) \\[ v_3 = \\sqrt{(11.2 \\times 10^3)^2 + (29.78 \\times 10^3)^2} \\approx 42.1 \\times 10^3 \\, \\text{m/s} \\] labels = list(results.keys()) v1_vals = [results[planet]['v1'] for planet in labels] v2_vals = [results[planet]['v2'] for planet in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_vals, width, label='2nd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show() 6. Importance in Space Exploration Application Required Velocity Satellite Orbiting \\(v_1\\) Escape to Moon/Mars \\(v_2\\) Voyager/Interstellar Missions \\(v_3\\) Launch Vehicles : Must reach \\(v_2\\) to leave Earth. Transfer Orbits : Use combinations of \\(v_1\\) and gravity assists. Deep Space Missions : Require planning to reach \\(v_3\\) using multiple planetary flybys. 7. Summary Table Planet 1st Cosmic Velocity (m/s) 2nd Cosmic Velocity (m/s) Earth \\~7,905 \\~11,186 Mars \\~3,550 \\~5,030 Jupiter \\~42,000 \\~59,540 Conclusion Cosmic velocities are fundamental for any space mission: v\u2081 : for stable orbits, v\u2082 : for escape trajectories, v\u2083 : for interstellar travel. These concepts are essential in mission planning, propulsion design, and the future of human spaceflight.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding the speeds required to enter orbit, escape planetary gravity, or even leave the Solar System is foundational to space exploration. These speeds\u2014called cosmic velocities \u2014determine how we launch satellites, send missions to other planets, and plan interstellar probes.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"Cosmic Velocity Description Formula First ( \\(v_1\\) ) Minimum speed to achieve stable circular orbit near the surface \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second ( \\(v_2\\) ) Minimum speed to escape the planet\u2019s gravity \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) Third ( \\(v_3\\) ) Speed to escape the star system from a planet\u2019s orbit \\(v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2}\\) Where: \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}\\) \\(M\\) : Mass of the celestial body \\(R\\) : Radius of the celestial body","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"For a stable circular orbit at radius \\(R\\) : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\]","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Set total energy to zero (kinetic + gravitational potential): \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{R}} \\]","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Escape velocity from the Sun starting from Earth\u2019s orbit: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{Earth orbit}}^2} \\] Where \\(v_{\\text{Earth orbit}} \\approx 29.78 \\times 10^3\\) m/s.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-computing-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 # Celestial bodies: name -> (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } def compute_cosmic_velocities(mass, radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 return v1, v2 # Compute velocities results = {} for planet, (mass, radius) in bodies.items(): v1, v2 = compute_cosmic_velocities(mass, radius) results[planet] = {'v1': v1, 'v2': v2} # Display results for planet, v in results.items(): print(f\"{planet}:\") print(f\" First Cosmic Velocity (v1): {v['v1']:.2f} m/s\") print(f\" Second Cosmic Velocity (v2): {v['v2']:.2f} m/s\\n\") Earth: First Cosmic Velocity (v1): 7909.68 m/s Second Cosmic Velocity (v2): 11185.98 m/s Mars: First Cosmic Velocity (v1): 3554.68 m/s Second Cosmic Velocity (v2): 5027.08 m/s Jupiter: First Cosmic Velocity (v1): 42567.51 m/s Second Cosmic Velocity (v2): 60199.54 m/s","title":"3. Python Code: Computing Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-visualization","text":"","title":"4. Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#bar-chart-of-velocities","text":"labels = list(results.keys()) v1_vals = [results[planet]['v1'] for planet in labels] v2_vals = [results[planet]['v2'] for planet in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_vals, width, label='2nd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"Bar Chart of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-third-cosmic-velocity-escape-the-solar-system","text":"From Earth: \\(v_2 \\approx 11.2 \\times 10^3 \\, \\text{m/s}\\) \\(v_{\\text{Earth orbit}} \\approx 29.78 \\times 10^3 \\, \\text{m/s}\\) \\[ v_3 = \\sqrt{(11.2 \\times 10^3)^2 + (29.78 \\times 10^3)^2} \\approx 42.1 \\times 10^3 \\, \\text{m/s} \\] labels = list(results.keys()) v1_vals = [results[planet]['v1'] for planet in labels] v2_vals = [results[planet]['v2'] for planet in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_vals, width, label='2nd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"5. Third Cosmic Velocity (Escape the Solar System)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-importance-in-space-exploration","text":"Application Required Velocity Satellite Orbiting \\(v_1\\) Escape to Moon/Mars \\(v_2\\) Voyager/Interstellar Missions \\(v_3\\) Launch Vehicles : Must reach \\(v_2\\) to leave Earth. Transfer Orbits : Use combinations of \\(v_1\\) and gravity assists. Deep Space Missions : Require planning to reach \\(v_3\\) using multiple planetary flybys.","title":"6. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#7-summary-table","text":"Planet 1st Cosmic Velocity (m/s) 2nd Cosmic Velocity (m/s) Earth \\~7,905 \\~11,186 Mars \\~3,550 \\~5,030 Jupiter \\~42,000 \\~59,540","title":"7. Summary Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Cosmic velocities are fundamental for any space mission: v\u2081 : for stable orbits, v\u2082 : for escape trajectories, v\u2083 : for interstellar travel. These concepts are essential in mission planning, propulsion design, and the future of human spaceflight.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Escape Velocities and Cosmic Velocities Motivation Understanding the speeds required to enter orbit, escape planetary gravity, or even leave the Solar System is foundational to space exploration. These speeds\u2014called cosmic velocities \u2014determine how we launch satellites, send missions to other planets, and plan interstellar probes. 1. Definitions of Cosmic Velocities Cosmic Velocity Description Formula First ( \\(v_1\\) ) Minimum speed to achieve stable circular orbit near the surface \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second ( \\(v_2\\) ) Minimum speed to escape the planet\u2019s gravity \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) Third ( \\(v_3\\) ) Speed to escape the star system from a planet\u2019s orbit \\(v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2}\\) Where: \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}\\) \\(M\\) : Mass of the celestial body \\(R\\) : Radius of the celestial body 2. Mathematical Derivations First Cosmic Velocity For a stable circular orbit at radius \\(R\\) : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Second Cosmic Velocity (Escape Velocity) Set total energy to zero (kinetic + gravitational potential): \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{R}} \\] Third Cosmic Velocity Escape velocity from the Sun starting from Earth\u2019s orbit: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{Earth orbit}}^2} \\] Where \\(v_{\\text{Earth orbit}} \\approx 29.78 \\times 10^3\\) m/s. 3. Python Code: Computing Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 # Celestial bodies: name -> (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } def compute_cosmic_velocities(mass, radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 return v1, v2 # Compute velocities results = {} for planet, (mass, radius) in bodies.items(): v1, v2 = compute_cosmic_velocities(mass, radius) results[planet] = {'v1': v1, 'v2': v2} # Display results for planet, v in results.items(): print(f\"{planet}:\") print(f\" First Cosmic Velocity (v1): {v['v1']:.2f} m/s\") print(f\" Second Cosmic Velocity (v2): {v['v2']:.2f} m/s\\n\") Earth: First Cosmic Velocity (v1): 7909.68 m/s Second Cosmic Velocity (v2): 11185.98 m/s Mars: First Cosmic Velocity (v1): 3554.68 m/s Second Cosmic Velocity (v2): 5027.08 m/s Jupiter: First Cosmic Velocity (v1): 42567.51 m/s Second Cosmic Velocity (v2): 60199.54 m/s 4. Visualization Bar Chart of Velocities labels = list(results.keys()) v1_vals = [results[planet]['v1'] for planet in labels] v2_vals = [results[planet]['v2'] for planet in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_vals, width, label='2nd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show() 5. Third Cosmic Velocity (Escape the Solar System) From Earth: \\(v_2 \\approx 11.2 \\times 10^3 \\, \\text{m/s}\\) \\(v_{\\text{Earth orbit}} \\approx 29.78 \\times 10^3 \\, \\text{m/s}\\) \\[ v_3 = \\sqrt{(11.2 \\times 10^3)^2 + (29.78 \\times 10^3)^2} \\approx 42.1 \\times 10^3 \\, \\text{m/s} \\] 6. Importance in Space Exploration Application Required Velocity Satellite Orbiting \\(v_1\\) Escape to Moon/Mars \\(v_2\\) Voyager/Interstellar Missions \\(v_3\\) Launch Vehicles : Must reach \\(v_2\\) to leave Earth. Transfer Orbits : Use combinations of \\(v_1\\) and gravity assists. Deep Space Missions : Require planning to reach \\(v_3\\) using multiple planetary flybys. 7. Summary Table Planet 1st Cosmic Velocity (m/s) 2nd Cosmic Velocity (m/s) Earth \\~7,905 \\~11,186 Mars \\~3,550 \\~5,030 Jupiter \\~42,000 \\~59,540 Conclusion Cosmic velocities are fundamental for any space mission: v\u2081 : for stable orbits, v\u2082 : for escape trajectories, v\u2083 : for interstellar travel. These concepts are essential in mission planning, propulsion design, and the future of human spaceflight. --","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"Understanding the speeds required to enter orbit, escape planetary gravity, or even leave the Solar System is foundational to space exploration. These speeds\u2014called cosmic velocities \u2014determine how we launch satellites, send missions to other planets, and plan interstellar probes.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-definitions-of-cosmic-velocities","text":"Cosmic Velocity Description Formula First ( \\(v_1\\) ) Minimum speed to achieve stable circular orbit near the surface \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second ( \\(v_2\\) ) Minimum speed to escape the planet\u2019s gravity \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) Third ( \\(v_3\\) ) Speed to escape the star system from a planet\u2019s orbit \\(v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2}\\) Where: \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}\\) \\(M\\) : Mass of the celestial body \\(R\\) : Radius of the celestial body","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-mathematical-derivations","text":"","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#first-cosmic-velocity","text":"For a stable circular orbit at radius \\(R\\) : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\]","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#second-cosmic-velocity-escape-velocity","text":"Set total energy to zero (kinetic + gravitational potential): \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{R}} \\]","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#third-cosmic-velocity","text":"Escape velocity from the Sun starting from Earth\u2019s orbit: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{Earth orbit}}^2} \\] Where \\(v_{\\text{Earth orbit}} \\approx 29.78 \\times 10^3\\) m/s.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-code-computing-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 # Celestial bodies: name -> (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } def compute_cosmic_velocities(mass, radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 return v1, v2 # Compute velocities results = {} for planet, (mass, radius) in bodies.items(): v1, v2 = compute_cosmic_velocities(mass, radius) results[planet] = {'v1': v1, 'v2': v2} # Display results for planet, v in results.items(): print(f\"{planet}:\") print(f\" First Cosmic Velocity (v1): {v['v1']:.2f} m/s\") print(f\" Second Cosmic Velocity (v2): {v['v2']:.2f} m/s\\n\") Earth: First Cosmic Velocity (v1): 7909.68 m/s Second Cosmic Velocity (v2): 11185.98 m/s Mars: First Cosmic Velocity (v1): 3554.68 m/s Second Cosmic Velocity (v2): 5027.08 m/s Jupiter: First Cosmic Velocity (v1): 42567.51 m/s Second Cosmic Velocity (v2): 60199.54 m/s","title":"3. Python Code: Computing Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-visualization","text":"","title":"4. Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#bar-chart-of-velocities","text":"labels = list(results.keys()) v1_vals = [results[planet]['v1'] for planet in labels] v2_vals = [results[planet]['v2'] for planet in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_vals, width, label='2nd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"Bar Chart of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-third-cosmic-velocity-escape-the-solar-system","text":"From Earth: \\(v_2 \\approx 11.2 \\times 10^3 \\, \\text{m/s}\\) \\(v_{\\text{Earth orbit}} \\approx 29.78 \\times 10^3 \\, \\text{m/s}\\) \\[ v_3 = \\sqrt{(11.2 \\times 10^3)^2 + (29.78 \\times 10^3)^2} \\approx 42.1 \\times 10^3 \\, \\text{m/s} \\]","title":"5. Third Cosmic Velocity (Escape the Solar System)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-importance-in-space-exploration","text":"Application Required Velocity Satellite Orbiting \\(v_1\\) Escape to Moon/Mars \\(v_2\\) Voyager/Interstellar Missions \\(v_3\\) Launch Vehicles : Must reach \\(v_2\\) to leave Earth. Transfer Orbits : Use combinations of \\(v_1\\) and gravity assists. Deep Space Missions : Require planning to reach \\(v_3\\) using multiple planetary flybys.","title":"6. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#7-summary-table","text":"Planet 1st Cosmic Velocity (m/s) 2nd Cosmic Velocity (m/s) Earth \\~7,905 \\~11,186 Mars \\~3,550 \\~5,030 Jupiter \\~42,000 \\~59,540","title":"7. Summary Table"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Cosmic velocities are fundamental for any space mission: v\u2081 : for stable orbits, v\u2082 : for escape trajectories, v\u2083 : for interstellar travel. These concepts are essential in mission planning, propulsion design, and the future of human spaceflight. --","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83c\udf0a Interference Patterns on a Water Surface \ud83d\udd0d Motivation Interference patterns occur when multiple wave sources interact, resulting in regions where wave amplitudes reinforce (constructive interference) or cancel (destructive interference) each other. On a water surface, such patterns provide a clear, intuitive way to understand wave superposition. By analyzing the interference patterns generated by sources at the vertices of a regular polygon, we gain insight into fundamental wave phenomena using simple visual and computational tools. \ud83d\udccc Task Summary Polygon Choice : Regular square (4 vertices) Wave Properties : Coherent sources with same amplitude, frequency, and wavelength Goal : Visualize and explain the resulting wave interference pattern \ud83d\udcd0 Wave Model Each source emits a circular wave described by: \\[ \\eta_i(x, y, t) = \\frac{A}{r_i} \\cdot \\cos(k r_i - \\omega t + \\phi_i) \\] Where: \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) \u2014 distance from source \\(i\\) \\(A\\) \u2014 amplitude \\(k = \\frac{2\\pi}{\\lambda}\\) \u2014 wave number \\(\\omega = 2\\pi f\\) \u2014 angular frequency \\(\\phi_i\\) \u2014 phase (same for coherent sources) The total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] \ud83e\uddea Python Simulation import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # amplitude \u03bb = 1 # wavelength f = 1 # frequency \u03c9 = 2 * np.pi * f k = 2 * np.pi / \u03bb \u03d5 = 0 # initial phase # Simulation grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Define polygon vertices (square, centered at origin) def polygon_vertices(n_sides, radius=2): return [(radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides)] vertices = polygon_vertices(4) # Square t = 0 # Snapshot at time t # Calculate the total wave \u03b7_sum = np.zeros_like(X) for (x0, y0) in vertices: R = np.sqrt((X - x0)**2 + (Y - y0)**2) # Avoid division by zero at source R[R == 0] = 1e-6 \u03b7 = (A / R) * np.cos(k * R - \u03c9 * t + \u03d5) \u03b7_sum += \u03b7 # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, \u03b7_sum, levels=100, cmap='RdBu') plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.scatter(*zip(*vertices), color='black', marker='o', label='Sources') plt.title(\"Water Surface Interference Pattern (Square Configuration)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis('equal') plt.tight_layout() plt.show() \ud83e\udde0 Observations & Analysis Constructive Interference : Occurs where the crests of multiple waves align. In the plot, these show as bright or dark bands depending on phase alignment. Destructive Interference : Where crests meet troughs, resulting in cancellation. Appears as neutral-colored regions between intense bands. Symmetry : The interference pattern reflects the symmetry of the square\u2014regular polygon sources lead to rotational and reflectional symmetry in the wave field. Fringes : The alternating high/low amplitude bands resemble interference fringes, similar to light in double-slit experiments. \ud83d\udcc8 Extensions To deepen the exploration: Try triangular or pentagonal configurations by changing polygon_vertices(3) or polygon_vertices(5) . Vary the initial phases \\(\\phi_i\\) to explore effects of phase shifts. Animate the pattern over time by varying t in a loop. \ud83d\udcc4 Conclusion This project illustrates how interference patterns on a water surface emerge from coherent wave sources arranged in geometric configurations. Using computational tools allows for detailed, dynamic investigation of wave phenomena, reinforcing key concepts in wave physics through visual and interactive exploration.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference patterns occur when multiple wave sources interact, resulting in regions where wave amplitudes reinforce (constructive interference) or cancel (destructive interference) each other. On a water surface, such patterns provide a clear, intuitive way to understand wave superposition. By analyzing the interference patterns generated by sources at the vertices of a regular polygon, we gain insight into fundamental wave phenomena using simple visual and computational tools.","title":"\ud83d\udd0d Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-summary","text":"Polygon Choice : Regular square (4 vertices) Wave Properties : Coherent sources with same amplitude, frequency, and wavelength Goal : Visualize and explain the resulting wave interference pattern","title":"\ud83d\udccc Task Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-model","text":"Each source emits a circular wave described by: \\[ \\eta_i(x, y, t) = \\frac{A}{r_i} \\cdot \\cos(k r_i - \\omega t + \\phi_i) \\] Where: \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) \u2014 distance from source \\(i\\) \\(A\\) \u2014 amplitude \\(k = \\frac{2\\pi}{\\lambda}\\) \u2014 wave number \\(\\omega = 2\\pi f\\) \u2014 angular frequency \\(\\phi_i\\) \u2014 phase (same for coherent sources) The total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\]","title":"\ud83d\udcd0 Wave Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # amplitude \u03bb = 1 # wavelength f = 1 # frequency \u03c9 = 2 * np.pi * f k = 2 * np.pi / \u03bb \u03d5 = 0 # initial phase # Simulation grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Define polygon vertices (square, centered at origin) def polygon_vertices(n_sides, radius=2): return [(radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides)] vertices = polygon_vertices(4) # Square t = 0 # Snapshot at time t # Calculate the total wave \u03b7_sum = np.zeros_like(X) for (x0, y0) in vertices: R = np.sqrt((X - x0)**2 + (Y - y0)**2) # Avoid division by zero at source R[R == 0] = 1e-6 \u03b7 = (A / R) * np.cos(k * R - \u03c9 * t + \u03d5) \u03b7_sum += \u03b7 # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, \u03b7_sum, levels=100, cmap='RdBu') plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.scatter(*zip(*vertices), color='black', marker='o', label='Sources') plt.title(\"Water Surface Interference Pattern (Square Configuration)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis('equal') plt.tight_layout() plt.show()","title":"\ud83e\uddea Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations-analysis","text":"Constructive Interference : Occurs where the crests of multiple waves align. In the plot, these show as bright or dark bands depending on phase alignment. Destructive Interference : Where crests meet troughs, resulting in cancellation. Appears as neutral-colored regions between intense bands. Symmetry : The interference pattern reflects the symmetry of the square\u2014regular polygon sources lead to rotational and reflectional symmetry in the wave field. Fringes : The alternating high/low amplitude bands resemble interference fringes, similar to light in double-slit experiments.","title":"\ud83e\udde0 Observations &amp; Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#extensions","text":"To deepen the exploration: Try triangular or pentagonal configurations by changing polygon_vertices(3) or polygon_vertices(5) . Vary the initial phases \\(\\phi_i\\) to explore effects of phase shifts. Animate the pattern over time by varying t in a loop.","title":"\ud83d\udcc8 Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This project illustrates how interference patterns on a water surface emerge from coherent wave sources arranged in geometric configurations. Using computational tools allows for detailed, dynamic investigation of wave phenomena, reinforcing key concepts in wave physics through visual and interactive exploration.","title":"\ud83d\udcc4 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \ud83e\udde0 Algorithm Overview (Graph-Theoretic Equivalent Resistance) \ud83e\udde9 Circuit Representation: Represent the circuit as an undirected graph G = (V, E) Nodes (V) are electrical junctions. Edges (E) are resistors, with weights representing resistance in ohms. \ud83d\udd01 Reduction Strategy: Series Detection : If a node has degree 2 , and is not a terminal node, and the two adjacent resistors are not part of a cycle \u2192 combine them in series: $$ R_{\\text{eq}} = R_1 + R_2 $$ Parallel Detection : If multiple resistors connect the same pair of nodes \u2192 combine in parallel: $$ \\frac{1}{R_{\\text{eq}}} = \\sum_i \\frac{1}{R_i} $$ Repeat reductions until only two nodes remain (source and sink). \ud83d\udcdc Pseudocode Summary function compute_equivalent_resistance(graph, node_start, node_end): while graph has more than two nodes: for each node in graph: if node is not start or end: if degree(node) == 2 and not in a cycle: combine series resistors for each pair of nodes with multiple edges: combine parallel resistors return resistance between node_start and node_end \ud83e\uddea Full Python Implementation import networkx as nx def combine_parallel_edges(G): \"\"\"Combine all parallel resistors between the same two nodes.\"\"\" edges = list(G.edges(data=True)) seen = set() for u, v, data in edges: if (u, v) in seen or (v, u) in seen: continue parallels = [(a, b, d) for a, b, d in edges if (a == u and b == v) or (a == v and b == u)] if len(parallels) > 1: # Combine using reciprocal rule inv_sum = sum(1 / d['resistance'] for _, _, d in parallels) R_eq = 1 / inv_sum G.remove_edges_from([(a, b) for a, b, _ in parallels]) G.add_edge(u, v, resistance=R_eq) seen.add((u, v)) def combine_series_nodes(G, start, end): \"\"\"Combine series resistors at non-terminal, degree-2 nodes not in cycles.\"\"\" nodes_to_check = [n for n in G.nodes() if n not in (start, end) and G.degree[n] == 2] for node in nodes_to_check: if not nx.cycle_basis(G, node): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors R1 = G[u][node]['resistance'] R2 = G[node][v]['resistance'] R_eq = R1 + R2 G.remove_node(node) G.add_edge(u, v, resistance=R_eq) def equivalent_resistance(G, start, end): \"\"\"Reduce graph to compute equivalent resistance between start and end.\"\"\" while True: prev_num_nodes = G.number_of_nodes() prev_num_edges = G.number_of_edges() combine_parallel_edges(G) combine_series_nodes(G, start, end) if G.number_of_nodes() == 2 and G.has_edge(start, end): return G[start][end]['resistance'] if G.number_of_nodes() == prev_num_nodes and G.number_of_edges() == prev_num_edges: break # No further simplification possible # If no direct edge, use resistance computation via network # Use Kirchhoff-based method: return resistance_via_laplacian(G, start, end) def resistance_via_laplacian(G, start, end): \"\"\"Use Laplacian matrix to compute effective resistance between nodes.\"\"\" import numpy as np L = nx.laplacian_matrix(G, weight='conductance').toarray() L = np.array(L, dtype=float) # Add conductance = 1/R for u, v, d in G.edges(data=True): G[u][v]['conductance'] = 1 / d['resistance'] # Remove one row/column to make Laplacian invertible L = L[:-1, :-1] L_inv = np.linalg.pinv(L) # Compute potential difference b = np.zeros(len(L) + 1) b[start] = 1 b[end] = -1 b = b[:-1] # same shape as L_inv V = L_inv @ b return abs(V[start] - V[end]) \ud83e\uddea Test Examples # Example 1: Simple Series G1 = nx.Graph() G1.add_edge(0, 1, resistance=5) G1.add_edge(1, 2, resistance=10) print(\"Series (5\u03a9 + 10\u03a9):\", equivalent_resistance(G1, 0, 2)) # Expect 15\u03a9 # Example 2: Simple Parallel G2 = nx.Graph() G2.add_edge(0, 1, resistance=5) G2.add_edge(0, 1, resistance=10) print(\"Parallel (5\u03a9 || 10\u03a9):\", equivalent_resistance(G2, 0, 1)) # Expect 3.33\u03a9 # Example 3: Nested Network G3 = nx.Graph() G3.add_edge(0, 1, resistance=3) G3.add_edge(1, 2, resistance=6) G3.add_edge(2, 3, resistance=3) G3.add_edge(0, 3, resistance=6) G3.add_edge(1, 3, resistance=2) print(\"Complex network:\", equivalent_resistance(G3, 0, 3)) # Combines nested series + parallel \ud83d\udcca Efficiency & Improvements Time Complexity Series/parallel reductions : linear in number of nodes/edges Cycle detection : DFS or union-find for optimization Laplacian resistance : O(n\u00b3) (matrix pseudoinverse) \u2014 expensive for large graphs Improvements Use disjoint-set (Union-Find) for faster cycle detection Optimize with graph contraction strategies Integrate symbolic computation for algebraic solutions (with sympy ) \u2705 Summary Graph theory simplifies the modeling and analysis of electrical circuits. This method is modular , scalable , and works with arbitrary topologies . The algorithm handles series , parallel , and nested configurations with minimal code changes. Future improvements could support symbolic calculations or real-time simulation.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#algorithm-overview-graph-theoretic-equivalent-resistance","text":"","title":"\ud83e\udde0 Algorithm Overview (Graph-Theoretic Equivalent Resistance)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#circuit-representation","text":"Represent the circuit as an undirected graph G = (V, E) Nodes (V) are electrical junctions. Edges (E) are resistors, with weights representing resistance in ohms.","title":"\ud83e\udde9 Circuit Representation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#reduction-strategy","text":"Series Detection : If a node has degree 2 , and is not a terminal node, and the two adjacent resistors are not part of a cycle \u2192 combine them in series: $$ R_{\\text{eq}} = R_1 + R_2 $$ Parallel Detection : If multiple resistors connect the same pair of nodes \u2192 combine in parallel: $$ \\frac{1}{R_{\\text{eq}}} = \\sum_i \\frac{1}{R_i} $$ Repeat reductions until only two nodes remain (source and sink).","title":"\ud83d\udd01 Reduction Strategy:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#pseudocode-summary","text":"function compute_equivalent_resistance(graph, node_start, node_end): while graph has more than two nodes: for each node in graph: if node is not start or end: if degree(node) == 2 and not in a cycle: combine series resistors for each pair of nodes with multiple edges: combine parallel resistors return resistance between node_start and node_end","title":"\ud83d\udcdc Pseudocode Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#full-python-implementation","text":"import networkx as nx def combine_parallel_edges(G): \"\"\"Combine all parallel resistors between the same two nodes.\"\"\" edges = list(G.edges(data=True)) seen = set() for u, v, data in edges: if (u, v) in seen or (v, u) in seen: continue parallels = [(a, b, d) for a, b, d in edges if (a == u and b == v) or (a == v and b == u)] if len(parallels) > 1: # Combine using reciprocal rule inv_sum = sum(1 / d['resistance'] for _, _, d in parallels) R_eq = 1 / inv_sum G.remove_edges_from([(a, b) for a, b, _ in parallels]) G.add_edge(u, v, resistance=R_eq) seen.add((u, v)) def combine_series_nodes(G, start, end): \"\"\"Combine series resistors at non-terminal, degree-2 nodes not in cycles.\"\"\" nodes_to_check = [n for n in G.nodes() if n not in (start, end) and G.degree[n] == 2] for node in nodes_to_check: if not nx.cycle_basis(G, node): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors R1 = G[u][node]['resistance'] R2 = G[node][v]['resistance'] R_eq = R1 + R2 G.remove_node(node) G.add_edge(u, v, resistance=R_eq) def equivalent_resistance(G, start, end): \"\"\"Reduce graph to compute equivalent resistance between start and end.\"\"\" while True: prev_num_nodes = G.number_of_nodes() prev_num_edges = G.number_of_edges() combine_parallel_edges(G) combine_series_nodes(G, start, end) if G.number_of_nodes() == 2 and G.has_edge(start, end): return G[start][end]['resistance'] if G.number_of_nodes() == prev_num_nodes and G.number_of_edges() == prev_num_edges: break # No further simplification possible # If no direct edge, use resistance computation via network # Use Kirchhoff-based method: return resistance_via_laplacian(G, start, end) def resistance_via_laplacian(G, start, end): \"\"\"Use Laplacian matrix to compute effective resistance between nodes.\"\"\" import numpy as np L = nx.laplacian_matrix(G, weight='conductance').toarray() L = np.array(L, dtype=float) # Add conductance = 1/R for u, v, d in G.edges(data=True): G[u][v]['conductance'] = 1 / d['resistance'] # Remove one row/column to make Laplacian invertible L = L[:-1, :-1] L_inv = np.linalg.pinv(L) # Compute potential difference b = np.zeros(len(L) + 1) b[start] = 1 b[end] = -1 b = b[:-1] # same shape as L_inv V = L_inv @ b return abs(V[start] - V[end])","title":"\ud83e\uddea Full Python Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#test-examples","text":"# Example 1: Simple Series G1 = nx.Graph() G1.add_edge(0, 1, resistance=5) G1.add_edge(1, 2, resistance=10) print(\"Series (5\u03a9 + 10\u03a9):\", equivalent_resistance(G1, 0, 2)) # Expect 15\u03a9 # Example 2: Simple Parallel G2 = nx.Graph() G2.add_edge(0, 1, resistance=5) G2.add_edge(0, 1, resistance=10) print(\"Parallel (5\u03a9 || 10\u03a9):\", equivalent_resistance(G2, 0, 1)) # Expect 3.33\u03a9 # Example 3: Nested Network G3 = nx.Graph() G3.add_edge(0, 1, resistance=3) G3.add_edge(1, 2, resistance=6) G3.add_edge(2, 3, resistance=3) G3.add_edge(0, 3, resistance=6) G3.add_edge(1, 3, resistance=2) print(\"Complex network:\", equivalent_resistance(G3, 0, 3)) # Combines nested series + parallel","title":"\ud83e\uddea Test Examples"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#efficiency-improvements","text":"","title":"\ud83d\udcca Efficiency &amp; Improvements"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#time-complexity","text":"Series/parallel reductions : linear in number of nodes/edges Cycle detection : DFS or union-find for optimization Laplacian resistance : O(n\u00b3) (matrix pseudoinverse) \u2014 expensive for large graphs","title":"Time Complexity"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#improvements","text":"Use disjoint-set (Union-Find) for faster cycle detection Optimize with graph contraction strategies Integrate symbolic computation for algebraic solutions (with sympy )","title":"Improvements"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#summary","text":"Graph theory simplifies the modeling and analysis of electrical circuits. This method is modular , scalable , and works with arbitrary topologies . The algorithm handles series , parallel , and nested configurations with minimal code changes. Future improvements could support symbolic calculations or real-time simulation.","title":"\u2705 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}